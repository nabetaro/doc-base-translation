#!/usr/bin/perl
# vim:cindent:ts=2:sw=2:et:fdm=marker:cms=\ #\ %s

use warnings;
use lib 'perl';
use Debian::DocBase::Common;
use Debian::DocBase::Utils;
use Debian::DocBase::StatusFile;
use Debian::DocBase::Programs::Dhelp;
use Debian::DocBase::Programs::Dwww;
use Debian::DocBase::Programs::Scrollkeeper;

=head1 NAME

install-docs - manage online Debian documentation

=cut



# set umask explicitly
umask 022;

=head1 SYNOPSIS

 install-docs [ -v, --verbose ]
              [ --no-update-menus ]
              -i --install | 
              -r --remove  |
              -s --status  |
              -L --listfiles
                <doc-id | file>

=head1 DESCRIPTION

B<install-docs> is a tool allow Debian package maintainers to register
documentation to various documentation systems.  It currently supports
B<dhelp>,  B<dwww>, B<doc-central>, and B<scrollkeeper> browsers.

This manual page provides a quick synopsis of B<install-docs> usage.
Full documentation can be found in the documentation, including a
description of the control file syntax and grammar.

=head1 OPTIONS

=over 4

=cut

while ($arg = shift) {

  if (($arg eq '-v') or ($arg eq '--verbose')) {

=item B<-v> | B<--verbose>

Operate verbosely.

=cut
    $verbose = 1;
    next;
  }

  if ($arg eq '--no-update-menus') {

=item B<--no-update-menus>

Inhibit running both L<update-menus(1)> (used for the L<dwww(8)> update program)
and L<scrollkeeper-update(8)>.

=cut
    $do_dwww_update = 0;
    next;
  }

  if (($arg eq '-i') or ($arg eq '--install')) {

=item B<-i> I<file> | B<--install> I<file>

Install the documentation described by the control file I<file>.

=cut
    # install new docs # {{{
    ($file = shift) or die "argument missing for `install'\n";
    ($#ARGV == -1) or warn ("ignoring additional arguments for `install'\n");
    ($file eq "-") and warn("ignoring invalid argument for `install'\n") and exit (0);
    $warn_nonexistent_files = 1;

    read_control_file($file);
    read_status_file(1);
    read_list_file();


    # update status
    $status{'Control-File'} = $file;
    $status_changed = 1;


    # register documents to subsystems
    register_dhelp();
    register_dwww();
    register_scrollkeeper();

    write_list_file();
    write_status_file(); 
    exit(0); # }}}

  } elsif (($arg eq '-r') or ($arg eq '--remove')) {

=item B<-r> I<docid> | B<--remove> I<docid>

Remove the documentation identified by the document identifier
I<docid>.  Document identifiers are tags which are set in the control
file, and usually correspond to the package name.

=cut
    # remove old docs # {{{
    ($docid = shift) or die "argument missing for `remove'\n";
    ($#ARGV == -1) or warn ("ignoring additional arguments for `remove'\n");
    ($file eq "-") and warn("ignoring invalid argument for `remove'\n") and exit (0);

    if ( ! read_status_file(1) ) {
      warn("Document `$docid' is not installed, cannot remove.\n");
      exit 0;
    }
    read_control_file($status{'Control-File'});
    read_list_file();

    # remove newly created files and unregister from menus
    remove_files();
    remove_omf_files() if $status{'Scrollkeeper-omf-file'};
    update_dwww_menus() if $status{'Registered-to-dwww'};
    update_scrollkeeper() if $status{'Registered-to-scrollkeeper'};

    # remove data files
    remove_data_files(); 

   exit 0; # }}}

  } elsif (($arg eq '-s') or ($arg eq '--status')) {

=item B<-s> I<docid> | B<--status> I<docid>

Display the status of the document identifier I<docid>.

=cut
    # display status # {{{
    ($docid = shift) or die "argument missing for `status'\n";
    ($#ARGV == -1) or die "too many arguments for `status'\n";

    read_status_file();
    read_list_file();
    read_control_file($status{'Control-File'});

    display_status_information(); # }}}

  } elsif (($arg eq '-L') or ($arg eq '--listfiles')) {

=item B<-L> I<docid> | B<--listfiles> I<docid>

List the files associated with the document identifier I<docid>.

=back

=cut
    # display file listning # {{{
    ($docid = shift) or die "argument missing for `listfiles'\n";
    ($#ARGV == -1) or die "too many arguments for `listfiles'\n";

    read_status_file();
    read_list_file();

    display_listing(); # }}}

  } else {
    die "invalid command line argument: $arg\n";
  }
}

exit 0;


sub display_listing { # {{{
  for $k (sort keys %list) {
    print "$k\n";
  }
} # }}}

sub read_list_file { # {{{
  my $list_file = "$DATA_DIR/$docid.list";
  return unless -f $list_file;

  open(L,"$list_file") 
    or die "$list_file: cannot open list file for reading: $!";
  while (<L>) {
    chomp;
    next if /^\s*$/o;
    $list{$_} = 1;
  }
  close(L) or die "$list_file: cannot close file: $!";
} # }}}

sub write_list_file { # {{{
  return unless $list_changed;

  my $list_file = "$DATA_DIR/$docid.list";

  open(L,">$list_file")
    or die "$list_file: cannot open list file for writing: $!";
  for $k (keys %list) {
    print L "$k\n";
  }
  close(L) or die "$list_file: cannot close file: $!";

  $list_changed = 0;
} # }}}



##
## assuming filehandle IN is the control file, read a section (or
## "stanza") of the doc-base control file and adds data in that
## section to the hash reference passed as an argument.  Returns 1 if
## there is data and 0 if it was empty
##
sub read_control_file_section { # {{{
  my $fh = shift;
  my ($pfields) = @_;

  my $empty = 1;
  my ($cf,$v);
  while (<$fh>) {
    chomp;
    s/\s*$//;                   # trim trailing whitespace

    # empty line?
    if (/^\s*$/o) {
      if ($empty) {
        next;
      } else {
        last;
      }
    }

    $empty = 0;

    # new field?
    if (/^(\S+)\s*:\s*(.*)$/) {
      ($cf,$v) = ($1,$2);
      $cf = lc $cf;
      #print STDERR "$cf -> $v\n";
      if (exists $$pfields{$cf}) {
        warn "warning: $cf: overwriting previous setting of control field";
      }
      $$pfields{$cf} = $v;
    } elsif (/^\s+(\S.*)$/) {
      $v = $&;
      defined($cf) or die "syntax error in control file: no field specified";
      #print STDERR "$cf -> $v (continued)\n";
      $$pfields{$cf} .= "\n$v";
    } else {
      die "syntax error in control file: $_";
    }
  }

  return not $empty;
} # }}}

# reads control file specified as argument
# output:
#    sets $docid
#    sets $doc_data to point to a hash containing the document data
#    sets @format_list, a list of pointers to hashes containing the format data
sub read_control_file { # {{{
  my ($file) = @_;

  my $fh=$file; 
  open($fh, $file) or 
    open($fh, "/usr/share/doc-base/$file") or
    die "$file: cannot open control file for reading: $!\n";

  $doc_data = {};
  read_control_file_section($fh, $doc_data) or die "error: empty control file";
  if (defined $$doc_data{'version'}) {
      warn "skipping $file, because of unsupported Version field\n" if ($verbose);
      exit 0;
  }      
  # check for required information
  ($docid = $$doc_data{'document'}) 
    or die "error in control file: `Document' value not specified";
  $$doc_data{'title'}
    or die "error in control file: `Title' value not specified";
  $$doc_data{'section'}
    or die "error in control file: `Section' value not specified";

  undef @format_list;
  $format_data = {};
  while (read_control_file_section($fh, $format_data)) {
    # adjust control fields
    $$format_data{'format'} =~ tr/A-Z/a-z/;
    # check for required information
    $$format_data{'format'}
      or die "error in control file: `Format' value not specified";
    $$format_data{'files'}
      or die "error in control file: `Files' value not specified";
      
    if ($verbose) {
      grep { $_ eq $$format_data{'format'} } @supported_formats
        or  warn "warning: ignoring unknown format `$$format_data{'format'}'";
    }
    if (grep { $_ eq $$format_data{'format'}} @need_index_formats) {
      $$format_data{'index'}
         or die "error in control file: `Index' value missing for format `" . $$format_data{'format'} . "'"
    } 

    my $ok = 1;
    if ($warn_nonexistent_files) {
      if (defined $$format_data{'index'} && ! -e $$format_data{'index'}) {
        warn "warning: file `$$format_data{'index'}' does not exist" if ($verbose);
        $ok = 0;
      }
      my @globlist = glob($$format_data{'files'});
      # if the mask doesn't contain any meta-characters, then glob simply returns its argument 
      pop @globlist if ($#globlist == 0 && ! -f $globlist[0]);
      if ($#globlist < 0) {
        warn "warning: file mask `$$format_data{'files'}' does not match any files" if ($verbose);
        $ok = 0;
      }    
    }

    push(@format_list,$format_data) if $ok;
    $format_data = {};
  }
  close($fh);
} # }}}

=head1 BUGS

None known, but a much more robust system is being planned as the next
generation of doc-base.

=head1 SEE ALSO

dwww(8), scrollkeeper(7), Debian doc-base Manual
F</usr/share/doc/doc-base/doc-base.html/index.html>, dhelp Manual
F</usr/share/doc/dhelp/dhelp.html>

=head1 AUTHOR

This program was originally written by Christian Schwarz
<schwarz@debian.org>, for the Debian GNU/Linux system, and the
next maintainer was Adam Di Carlo <aph@debian.org>.
Robert Luberda <robert@debian.org> is currently maintaining and extending it.

This software was meant to be for the benefit of the entire Debian
user and developer community.  If you are interested in being involved
with this software, please join the mailing list
<debian-doc@lists.debian.org>.

=cut

#Local Variables:
#perl-indent-level:2
#End:
